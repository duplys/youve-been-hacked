\begin{frame}
    \frametitle{State}
        \begin{itemize}
        \item HTTP, the protocol for transfering data between the server and the client, is stateless
        \item Example: HTTP doesn't manage information about pages previously visited by the client, i.e., any URL can be requested by the client at any time. 
        \item If statefulness is required (e.g., page B shall only be served if the client has previously visited page A), the web application must manage a \textit{session}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{statefulness: Web Shop Example}
    \begin{itemize}
        \item Malicious user adds items into the shopping cart
        \item She then skips the page where credit card information must be entered and proceeds directly to the checkout page
        \item If the web application doesn't enforce the correct sequence of pages, the user would succesfully place an order without having entered any payment details 
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Managing State Information}
    There are two options to manage state information in web:
    \begin{itemize}
        \item the state information is stored on the server; the users are identified using a \textit{session ID}
        \item the state information is stored on the client
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Hidden Input Fields}
    State information can be located in hidden input fields, e.g., 
    \begin{center}
        \begin{verbatim}
            <input name="id" value="1234" type="hidden">        
        \end{verbatim}
    \end{center}

    Such data fields can be easily manipulated using a tool like ZAP-Proxy or using web developer tools in the web browser. Thus, an attacker can easily manipulate hidden input fields. 
\end{frame}

\begin{frame}
    \frametitle{Hidden Input Fields: Finding Vulnerabilities}
    For every hidden input field in the application, you must examine whether the web application's behavior changes if the values of these input fields are altered.

    A classical anti-pattern (luckily not so common anymore) is the use of hidden input fields for storing item price in a web shop. Yet another example is the storage of the user's status, e.g., a signed in user instead of a "guest" or administrator instead of a standard user.
\end{frame}

\begin{frame}
    \frametitle{Hidden Input Fields: Protecting Against Attacks}
    \begin{itemize}
        \item Core issue with hidden input fields: state information is stored \textit{on the client} where it can be easily manipulated by a malicious user
        \item Main defense philosophy: \textit{never trust the client}
        \item Critical information must always be stored on the server
        \item Values received from the client must always be checked \& validated
        \item If values must be stored on the client (e.g., session IDs), they should be encrypted or hashed
    \end{itemize}     
\end{frame}

\begin{frame}
    \frametitle{URL Parameters}
    \begin{itemize}
        \item (State) information can be transmitted in the URL
        \item In contrast to forms, transmitting information via URL parameters does not require clicking a submit button
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{URL Parameters: Finding Vulnerabilities}
    \begin{itemize}
        \item Using URL parameters to transmit information is a threat, because it is trivial to manipulate them
        \item Look for URL parameters identified during the recon phase
        \item Investigate what happens when you change these parameters. Does this cause an unexpected and unintended change of the state of the web application?
        \item \verb|http://www.webapp.example/editprofile.php?id=123|
        \item What happens when you change \verb|id|? Can you edit the profile of a different user?
        \item Are there (hidden) parameters to activate debug information, e.g., \verb|debug=on|, \verb|debug=1| or \verb|debug=true|?
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{URL Parameters: Defending Against Attacks}
    \begin{itemize}
        \item Core issue with URL parameters: state information is stored \textit{on the client} where it can be easily manipulated by a malicious user
        \item URL parameters must always be checked \& validated
        \item If possible, they should be encrypted or hashed
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Cookie Parameters}
    \begin{itemize}
        \item For a long time, cookies were the only option to persistently store data on the client
        \item It is still the prevailing solution
        \item Cookies are frequently used for user identification, e.g., at consecutive visits of a web application
        \item Attacks based on cookie manipulation are called \textit{cookie poisoning}  
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Cookies}
    \begin{itemize}
        \item Persistent vs non-persistent cookies
        \item \verb|secure| vs \verb|HttpOnly| cookies
        \item Persistent cookies are stored on client's hard drive as long as their date is validated
        \item Non-persistent cookies are stored in RAM and are deleted when the web browser is closed
        \item \verb|secure| cookies are transmitted only via an HTTPS connection
        \item \verb|HttpOnly| cookies are transmitted via HTTP or HTTPS, but cannot be accessed by JavaScript
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Cookie Parameters: Storage and Manipulation}
    \begin{itemize}
        \item All web browsers store cookies in known filesystem locations and in known formats
        \item An attacker can easily manipulate this data before it is used by a web application
        \item It is possible to manipulate cookies \textit{on the fly}, e.g., using a tool like the ZAProxy
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Cookie Parameters: Storage and Manipulation}
    \begin{itemize}
        \item Unlike with URL parameters, the attacker can also manipulate the date when the cookie expires, i.e., she can manipulate the cookie's lifetime
        \item In general, cookies can give you access to things like sessions, profiles, etc.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Cookie Parameters: Storage and Manipulation}
    Example:
    \begin{itemize}
        \item \texttt{weather.xyz} offers detailed weather information against payment
        \item \texttt{weather.xyz} uses cookies that contain \texttt{userID} to identify users
        \item The cookie is valid for the user's subscription period, e.g., a month
        \item Information stored in the cookie is processed by \texttt{weather.xyz} without additional authentication
        \item Attack 1: malicious user manipulates \texttt{userID} to acess \texttt{weather.xyz} as another user
        \item Attack 2: malicious user extends their subscription by manipulating the cookie expiration date (by changing the Unix-timestamp in the cookie)
        \item Attack 3: cookies often store the number of failed login attempts. When they reach a specific threshold, say 5, \texttt{weather.xyz} deactivates that user account for 10 minutes to protect against brute force attacks. The attacker bypasses this defense by setting the value of failed login attempts to 0 after each login attempt. Since this can be easily automated, brute force attacks become trivial.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Cookie Parameters: Finding Vulnerabilities}
    \begin{itemize}
        \item For every cookie found during recon phase, you must check whether a parameter manipulation results in an illegal state change of the web application
        \item Manipulation should also include cookie parameters like expiration
        \item To detect cookie-related vulnerabilities more efficiently, \textit{decrease} the expiration date and check whether the web application denies its service
        \item As an alternative -- if you have access to the server-side source code of the web application -- check whether the source code uses the cookie expiration date as input parameter
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Cookie Parameters: Defending Against Attacks}
    \begin{itemize}
        \item 
    \end{itemize}
\end{frame}


\begin{frame}
    \frametitle{URL Jumping}
    \begin{itemize}
        \item 
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{URL Jumping}
    \begin{itemize}
        \item 
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{URL Jumping}
    \begin{itemize}
        \item 
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{URL Jumping}
    \begin{itemize}
        \item 
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{URL Jumping}
    \begin{itemize}
        \item 
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{URL Jumping}
    \begin{itemize}
        \item 
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{URL Jumping}
    \begin{itemize}
        \item 
    \end{itemize}
\end{frame}